package fr.jmmc.jmcs.gui.util;import fr.jmmc.jmcs.util.StringUtils;import java.awt.Component;import java.awt.Dimension;import java.awt.FontMetrics;import javax.swing.JLabel;import javax.swing.JTable;import javax.swing.SwingUtilities;import javax.swing.table.DefaultTableCellRenderer;import javax.swing.table.JTableHeader;import javax.swing.table.TableCellRenderer;import javax.swing.table.TableColumn;import javax.swing.table.TableColumnModel;import javax.swing.text.JTextComponent;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * This utility class is useful to adjust the column width of a JTable according to its content *  * @author laurent Bourges */public final class AutofitTableColumns {    /** Logger */    private static final Logger _logger = LoggerFactory.getLogger(AutofitTableColumns.class.getName());    /** internal debug flag */    private static final boolean DEBUG = false;    /** maximum width for a column header */    private static final int MAX_WIDTH_HEADER = 50;    /** header padding */    private static final int DEFAULT_COLUMN_PADDING_HEADER = 20;    /** padding */    private static final int DEFAULT_COLUMN_PADDING = 20;    /**     * Hidden constructor     */    private AutofitTableColumns() {        // not used    }    /**     * Adjust columns width taking into account the content of the table and the used font with default column padding     * @param aTable the JTable to autoresize the columns on     * @return table width     */    public static int autoResizeTable(final JTable aTable) {        return autoResizeTable(aTable, true);    }    /**     * Adjust header and columns width taking into account the content of the table and the used font with default column padding     * @param aTable the JTable to autoresize the columns on     * @param includeColumnHeaderWidth use the Column Header width as a minimum width     * @return table width     */    public static int autoResizeTable(final JTable aTable, final boolean includeColumnHeaderWidth) {        return autoResizeTable(aTable, includeColumnHeaderWidth, DEFAULT_COLUMN_PADDING);    }    /**     * Adjust header and columns width taking into account the content of the table and the used font     * @param aTable the JTable to autoresize the columns on     * @param includeColumnHeaderWidth use the Column Header width as a minimum width     * @param columnPadding how many extra pixels do you want on the end of each column     * @return table width     */    private static int autoResizeTable(final JTable aTable, final boolean includeColumnHeaderWidth, final int columnPadding) {        final long startTime = System.nanoTime();        int tableWidth = 0;        final int columnCount = aTable.getColumnCount();        // must have columns :        if (columnCount > 0) {            final Dimension interCellSpacing = aTable.getIntercellSpacing();            // STEP ONE : Work out the column widths            final int columnWidth[] = new int[columnCount];            for (int i = 0; i < columnCount; i++) {                columnWidth[i] = getMaxColumnWidth(aTable, i, includeColumnHeaderWidth, columnPadding);                tableWidth += columnWidth[i];            }            // account for cell spacing too            tableWidth += ((columnCount - 1) * interCellSpacing.width);            // STEP TWO : Dynamically resize each column            // try changing the size of the column names area            final JTableHeader tableHeader = aTable.getTableHeader();            final Dimension headerDim = tableHeader.getPreferredSize();            headerDim.width = tableWidth;            tableHeader.setMinimumSize(headerDim);            tableHeader.setPreferredSize(headerDim);            final TableColumnModel tableColumnModel = aTable.getColumnModel();            TableColumn tableColumn;            for (int i = 0; i < columnCount; i++) {                tableColumn = tableColumnModel.getColumn(i);                tableColumn.setPreferredWidth(columnWidth[i]);            }            aTable.getPreferredSize().width = tableWidth;            aTable.invalidate();            aTable.doLayout();            aTable.repaint();        }        if (_logger.isDebugEnabled()) {            _logger.debug("autoResizeTable done in {} ms.", 1e-6d * (System.nanoTime() - startTime));        }        return tableWidth;    }    /**     * Computes the maximum column width according to the content of the table column.      * If the table size is big, then process only some of them (1/20)     * @param aTable the JTable to autoresize the columns on     * @param columnNo the column number, starting at zero, to calculate the maximum width on     * @param includeColumnHeaderWidth use the Column Header width as a minimum width     * @param columnPadding how many extra pixels do you want on the end of each column     * @return table width     */    private static int getMaxColumnWidth(final JTable aTable, final int columnNo,            final boolean includeColumnHeaderWidth, final int columnPadding) {        int maxWidth = 0;        int textWidth = 0;        TableCellRenderer tableCellRenderer;        Component comp;        JTextComponent jtextComp;        JLabel jLabelComp;        FontMetrics fontMetrics;        final TableColumn column = aTable.getColumnModel().getColumn(columnNo);        if (includeColumnHeaderWidth) {            final TableCellRenderer headerRenderer = column.getHeaderRenderer();            if (headerRenderer != null) {                comp = headerRenderer.getTableCellRendererComponent(aTable, column.getHeaderValue(), false, false, 0, columnNo);                if (comp instanceof JTextComponent) {                    jtextComp = (JTextComponent) comp;                    if (!StringUtils.isEmpty(jtextComp.getText())) {                        fontMetrics = jtextComp.getFontMetrics(jtextComp.getFont());                        textWidth = getHeaderWidth(fontMetrics, jtextComp.getText());                    }                } else {                    textWidth = comp.getPreferredSize().width;                }            } else {                try {                    final String text = (String) column.getHeaderValue();                    if (!StringUtils.isEmpty(text)) {                        final JTableHeader tableHeader = aTable.getTableHeader();                        fontMetrics = tableHeader.getFontMetrics(tableHeader.getFont());                        textWidth = getHeaderWidth(fontMetrics, text);                    }                } catch (ClassCastException ce) {                    // Can't work out the header column width.                    textWidth = 0;                }            }            maxWidth = textWidth;        }        int cellWidth;        final int size = aTable.getRowCount();        final int threshold = 5000;        // only 5% values are evaluated for performance reasons:        final int step = (size > threshold) ? size / 20 : 1;        final int start = (size > threshold) ? ((size > 10) ? 5 : (size > 2) ? 2 : 0) : 0;        if (DEBUG && _logger.isDebugEnabled()) {            _logger.debug("getMaxColumnWidth : table rowCount : " + size + " - step : " + step + " - start : " + start);        }        // cache cell renderer :        tableCellRenderer = null;        // cache fontMetrics :        fontMetrics = null;        // skip first cell :        for (int i = start; i < size; i += step) {            if (tableCellRenderer == null) {                tableCellRenderer = aTable.getCellRenderer(i, columnNo);            }            comp = tableCellRenderer.getTableCellRendererComponent(aTable, aTable.getValueAt(i, columnNo), false, false, i, columnNo);            if (comp instanceof DefaultTableCellRenderer) {                jLabelComp = ((DefaultTableCellRenderer) comp);                if (fontMetrics == null) {                    fontMetrics = jLabelComp.getFontMetrics(jLabelComp.getFont());                }                textWidth = SwingUtilities.computeStringWidth(fontMetrics, jLabelComp.getText());                maxWidth = max(maxWidth, textWidth);            } else if (comp instanceof JTextComponent) {                jtextComp = (JTextComponent) comp;                if (fontMetrics == null) {                    fontMetrics = jtextComp.getFontMetrics(jtextComp.getFont());                }                textWidth = SwingUtilities.computeStringWidth(fontMetrics, jtextComp.getText());                maxWidth = max(maxWidth, textWidth);            } else {                cellWidth = comp.getPreferredSize().width;                maxWidth = max(maxWidth, cellWidth);            }        }        maxWidth += columnPadding;        return maxWidth;    }    /**     * Computes header width (takes care of html and multi line text) but limited to MAX_WIDTH_HEADER     * @param fontMetrics font in use     * @param text content to analyze     * @return largest line width     */    private static int getHeaderWidth(final FontMetrics fontMetrics, final String text) {        // note: text must not contain html code as it will be interpreted as text not code:        int maxWidth = SwingUtilities.computeStringWidth(fontMetrics, text);        maxWidth += DEFAULT_COLUMN_PADDING_HEADER;        if (maxWidth > MAX_WIDTH_HEADER) {            maxWidth = MAX_WIDTH_HEADER;        }        return maxWidth;    }    /**     * Return the maximum (a, b)     * @param a value     * @param b value     * @return max(a,b)     */    public static int max(final int a, final int b) {        return (a >= b) ? a : b;    }}