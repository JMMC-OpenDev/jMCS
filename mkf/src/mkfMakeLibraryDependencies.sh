#! /bin/sh
#*******************************************************************************
# JMMC project
#
# "@(#) $Id: mkfMakeLibraryDependencies.sh,v 1.5 2009-05-28 10:35:24 mella Exp $" 
#
# History
# -------
# $Log: not supported by cvs2svn $
# Revision 1.4  2005/02/15 08:40:15  gzins
# Added CVS log as file modification history
#
# gzins     26-Aug-2004  Adapted from VLT
# gzins     18-Nov-2004  Added MCS C++ libraries only when MCS and C++ are
#                        specified
# gzins     18-Nov-2004  Fixed bug related to MCS C++ libraries
#
#************************************************************************
#   NAME
#   mkfMakeLibraryDependencies - create the makefile to build a library
# 
#   SYNOPSIS
#
#     mkfMakeLibraryDependencies  <libName> <objectList> <ldFlags> [<noshared>]
#
# 
#   DESCRIPTION
#   Utility used by mkfMakefile to create the makefile to build a library.
#   It is not intended to be used as a standalone command.
#
#   Unless <noshared> is specified, both static and shared libraries 
#   are produced.
# 
#   The library depends on library member (object files).
#   How to make a library member is given from an implicit pattern rule
#   defined in mkfMakefile, so there is no need here to be specified.
#
#   The .da itself depends to Makefile.
#
#   The rules is written to standard output.
#
#   <libName>     The name of the library 
#                 (Without neither directory nor .a suffix)
#
#   <object List> The list of the object forming the library
#                 (Without neither directory nor .a suffix)
#
#   <ldFlags>     passed to the linker (for shared only!)
#
#   <noshared>    if defined, the shared library is NOT produced
#
#   <libList>     the list of libraries needed to link.
#                 The list can contain "conventional" names that direct the
#                 procedure to create the needed generation rules
#
#   FILES
#   $MCSROOT/include/mkfMakefile   
#
#   ENVIRONMENT
#
#   RETURN VALUES
#
#   SEE ALSO 
#   mkfMakefile, Makefile, (GNU) make
#
#   BUGS    
#
#----------------------------------------------------------------------

libName=$1
objectList=${2}
ldFlags=${3}
noshared=${4}
libList=${5}

staticLib=../lib/lib${libName}.a

#
# shared libraries have different extension on SUN and HP
if [ "`uname`" = "HP-UX" ]
then
    sharedLib=../lib/lib${libName}.sl
    # on HP, the way it works by default does not require any explicit name
    sharedLibName=""
else
    sharedLib=../lib/lib${libName}.so
    # on SUN, by default the library is created with "../lib/lib...."
    # as internal name. This gives problems at run time in finding the 
    # the correct file (see ldd output) 
    # Here I force the name without parent directory 
    if [ "`uname`" != "Darwin" ]
    then
        sharedLibName="-Xlinker -h -Xlinker lib${libName}.so"
    fi
fi 

echo "# Dependency file for library: ${libName}"
echo "# Created automatically by mkfMakeLibraryDependencies -  `date '+%d.%m.%y %T'`"
echo "# DO NOT EDIT THIS FILE"
echo "../object/${libName}.da: Makefile"
echo ""

#
# define PHONY the target, so make does not try to make the target
# when no object are specified. (due to the fact that the same list of objects is
# used to build the list of lib both to be produced and to be installed).
echo ".PHONY: ${libName} "
echo ""

#
# if the list of objects is not empty, the rule to build the lib is written on output.
if [ "${objectList}" != "" ]
then
    # prepare full-pathname object file list

    echo "xyz_${libName}_OBJ = \\"
    for member in ${objectList}
    do
        echo "                 ../object/${member}.o \\"
    done
    echo ""

    #
    # prepare the lists in the "-l<name>" format of all libraries used in linking
    # some library names can be conventional names that are expanded in a series of
    # predefined libraries or flags
        echo "libList = $libList"
    for member in ${libList}
    do
        echo "member = $member"
        case $member in

        MCS):
            mcs="yes"
            ;;
        C++):
            cpp="yes"
            case "`uname`" in

            HP-UX):
                case "`uname -r`" in
                B.10.20):
                      lList="${lList} -lstdc++ -ldce"
                      ;;
                B.11.00):
                      lList="${lList} -lstdc++"
                      ;;
                esac
                ;;

            SunOS):
                lList="${lList} -lstdc++ "
                ;;

            Linux):
                lList="${lList} -lstdc++ "
                ;;

            *):
                MESSAGE="$MESSAGE -- error: this Operating System is not supported"
                ;;
            esac
            ;;

        stdc++):
            lList="${lList} -l${member}"
            MESSAGE="$MESSAGE -- warning: in ${exeName}_LIB: please remove ${member} and use  C++  to link c++ libraries"
            ;;

        g++):
            MESSAGE="$MESSAGE -- warning: in ${exeName}_LIB: egcs does not provide g++ anylonger. Please remove ${member} and use  C++  to link c++ libraries"
            ;;

        iostream):
            MESSAGE="$MESSAGE -- warning: in ${exeName}_LIB: ${member} is not supported since GCC 2.7, please remove it."
            ;;

        *):
            lList="${lList} -l${member}"
            ;;
        esac
    done

    #
    # There is the possibility to use or to use not shared
    # libraries.
    # The dependency file is build only when either the source or Makefile is
    # touched, therefore to allow the user to chose at run time, make
    # variables are used so they get the actual value and something like  make
    # MAKE_NOSHARED=on  works.
    # build up the list of libraries with and without directive to use share lib.
    
    libraryList="\$(GEN_LIBLIST)"
    libraryListNoshared="\$(GEN_LIBLIST_NOSHARED)"
    
    if [ "${lList}" != "" ]
    then
        libraryList="${libraryList} ${lList}"
        libraryListNoshared="${libraryListNoshared} \$(NOSHARED_ON) ${lList} \$(NOSHARED_OFF)"
    fi
    
    if [ "${mcs}" = "yes" ]
    then 
        if [ "${cpp}" = "yes" ]
        then 
            libraryList="${libraryList} \$(MCSCPP_LIBLIST)"
            libraryListNoshared="${libraryListNoshared} \$(MCSCPP_LIBLIST_NOSHARED)"
        else
            libraryList="${libraryList} \$(MCS_LIBLIST)"
            libraryListNoshared="${libraryListNoshared} \$(MCS_LIBLIST_NOSHARED)"
        fi
        libraryList="${libraryList} \$(MCSSTD_LIBLIST)"
        libraryListNoshared="${libraryListNoshared} \$(MCSSTD_LIBLIST)"
    fi
    
    echo "libraryList = $libraryList"
    #
    # create a target with the <name> of the library/ies to be produced
    # (make <name>)

    # if <lib>_NOSHARED is defined no shared library is produced
    if [ "${noshared}" != "" ]
    then
        echo "${libName}: ${staticLib}"
    else
        echo "${libName}: ${staticLib} ${sharedLib}"
    fi
    
    echo ""

 
    # output the rule to build the static library   
    # for the time being, libraries are always regenerated from scratch 
    # (See also mkfMakefile)
    echo "${staticLib}: \$(xyz_${libName}_OBJ)"
    echo "	@echo \"== Making library: ${staticLib}\" "
    echo "	-\$(AT)\$(RM) ${staticLib} "
    echo "	\$(AT)\$(AR) rc  ${staticLib} \$(xyz_${libName}_OBJ)"
    echo "	\$(AT)\$(RANLIB) ${staticLib}"

    #
    # shared only for UNIX and when required
    if [ "${noshared}" = "" ]
    then
        echo ""
        # output the rule to build the shared library (.sl or .so)
        echo "${sharedLib}: \$(xyz_${libName}_OBJ) ${lList}"
        echo "	@echo \"== Making library: ${sharedLib}\" "
        echo "	-\$(AT)\$(RM) ${sharedLib} "
        echo "	\$(AT)\$(LD) -shared -fPIC ${sharedLibName} \$(L_PATH) ${libraryList} ${ldFlags} -o ${sharedLib} \$(xyz_${libName}_OBJ)"
        echo "	\$(AT) chmod a-w ${sharedLib} "
    fi
    echo "	@echo "
    
else
    echo "	@echo "
    echo "	@echo \"WARNING>>>>> ${libName}_OBJECTS is not defined. \" "
    echo "	@echo \"             check your Makefile \" "
    echo "	@echo "
fi
#
# ___oOo___
